system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
params$label_names <- annotations$categories$name
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
source('CNN_output_analysis.R',echo= TRUE) # analyse resulting CNN (or a loaded CNN)
table_train  # confusion matrix
table_val # confusion matrix
##################################################################################
# SVM stuff from here
source('Disease_fake_data.R',echo= TRUE) # creates dataframes to train SVM model.
source('SVM.R',echo= TRUE) # trains SVM
if(run_analyse_SVM_output==1){
source('SVM_output_analysis.R',echo= TRUE) # analyse output and create function to test new data
# now can predict for 'new data'
val_data$name[1]
dis_number<-which(name_disease == val_data$name[1])
# assume categorical variables are for the average case of disease appearance
categorical_test_sample<-list('location'=if(crop_bias[[dis_number]]<0){"Midlands"}else{"East_Anglia"},
'rainfall'=rain_av[dis_number],
'mean_temp'=temp_av[dis_number],
'crop_variety'=if(crop_bias[[dis_number]]<0){"WB2"}else{"WB1"},
'soil_type'=if(soil_bias[[dis_number]]<0){"sandy"}else{"clay"})
SVM_predictor(svm_no_images$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
SVM_predictor(svm_im_only$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
SVM_predictor(svm_all$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
}
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-0
run_analyse_CNN_output<-1
run_analyse_SVM_output<-1
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
params$label_names <- annotations$categories$name
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
source('CNN_output_analysis.R',echo= TRUE) # analyse resulting CNN (or a loaded CNN)
table_train  # confusion matrix
table_val # confusion matrix
##################################################################################
# SVM stuff from here
source('Disease_fake_data.R',echo= TRUE) # creates dataframes to train SVM model.
source('SVM.R',echo= TRUE) # trains SVM
if(run_analyse_SVM_output==1){
source('SVM_output_analysis.R',echo= TRUE) # analyse output and create function to test new data
# now can predict for 'new data'
val_data$name[1]
dis_number<-which(name_disease == val_data$name[1])
# assume categorical variables are for the average case of disease appearance
categorical_test_sample<-list('location'=if(crop_bias[[dis_number]]<0){"Midlands"}else{"East_Anglia"},
'rainfall'=rain_av[dis_number],
'mean_temp'=temp_av[dis_number],
'crop_variety'=if(crop_bias[[dis_number]]<0){"WB2"}else{"WB1"},
'soil_type'=if(soil_bias[[dis_number]]<0){"sandy"}else{"clay"})
SVM_predictor(svm_no_images$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
SVM_predictor(svm_im_only$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
SVM_predictor(svm_all$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
}
CNN_model
params$cl_output
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-0
run_analyse_CNN_output<-1
run_analyse_SVM_output<-1
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
# use annotations to correctly update parameters automatically.
params$label_names <- annotations$categories$name
params$cl_output <- length(params$label_names)
params$class_background <- length(params$label_names)
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
source('CNN_output_analysis.R',echo= TRUE) # analyse resulting CNN (or a loaded CNN)
table_train  # confusion matrix
table_val # confusion matrix
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-0
run_analyse_CNN_output<-1
run_analyse_SVM_output<-1
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
# use annotations to correctly update parameters automatically.
params$label_names <- annotations$categories$name
params$cl_output <- length(params$label_names)
params$class_background <- length(params$label_names)
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
####
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
valid_gen
CNN_model
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-0
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
# use annotations to correctly update parameters automatically.
params$label_names <- annotations$categories$name
params$cl_output <- length(params$label_names)
params$class_background <- length(params$label_names)
####
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
params
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
train_data
validation_data
train_data$category_id
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-1
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
# use annotations to correctly update parameters automatically.
params$label_names <- annotations$categories$name
params$cl_output <- length(params$label_names)
params$class_background <- length(params$label_names)
####
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
params
####
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
typeof(params$class_background)
typeof(params$label_names)
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-0
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
# use annotations to correctly update parameters automatically.
params$label_names <- annotations$categories$name
params$cl_output <- length(params$label_names)
params$class_background <- length(params$label_names)
####
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
####
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
params$label_names
typeof(params$label_names)
typeof(annotations$categories$name)
typeof(c("YR","MSD","BS"))
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-0
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
# use annotations to correctly update parameters automatically.
params$label_names <- annotations$categories$name
params$cl_output <- length(params$label_names)
params$class_background <- length(params$label_names)
####
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
####
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
class_list <- vector()
typeof(class_list)
class_list <- c("names_will_go_in_here")
typeof(class_list)
class_list<-c("1","2","3")
typeof(class_list)
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-0
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
# use annotations to correctly update parameters automatically.
params$label_names <- annotations$categories$name
params$cl_output <- length(params$label_names)
params$class_background <- length(params$label_names)
####
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
typeof(params$label_names)
typeof(params$cl_output)
typeof(params$class_background)
####
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
####
source('CNN_output_analysis.R',echo= TRUE) # analyse resulting CNN (or a loaded CNN)
table_train  # confusion matrix
table_val # confusion matrix
##################################################################################
# SVM stuff from here
source('Disease_fake_data.R',echo= TRUE) # creates dataframes to train SVM model.
source('SVM.R',echo= TRUE) # trains SVM
#####
source('SVM_output_analysis.R',echo= TRUE) # analyse output and create function to test new data
# now can predict for 'new data'
val_data$name[1]
dis_number<-which(name_disease == val_data$name[1])
# assume categorical variables are for the average case of disease appearance
categorical_test_sample<-list('location'=if(crop_bias[[dis_number]]<0){"Midlands"}else{"East_Anglia"},
'rainfall'=rain_av[dis_number],
'mean_temp'=temp_av[dis_number],
'crop_variety'=if(crop_bias[[dis_number]]<0){"WB2"}else{"WB1"},
'soil_type'=if(soil_bias[[dis_number]]<0){"sandy"}else{"clay"})
SVM_predictor(svm_no_images$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
SVM_predictor(svm_im_only$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
SVM_predictor(svm_all$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
testing_data<-tr_data
###
###
box_predictions_individual<-list()
class_preds_individual<-list()
for (i in 1:length(testing_data$name)) {
preds <-  CNN_model %>% predict(
load_and_preprocess_image(testing_data[i, "file_name"],
params$target_height, params$target_width),
batch_size = 1
)
box_predictions_individual[[i]]<-as.data.frame(preds[[1]])
class_preds_individual[[i]] <- as.data.frame(preds[[2]])
}
box_predictions<- do.call(rbind, box_predictions_individual)
class_preds    <- do.call(rbind, class_preds_individual)
# now have model predictions for all of our data
###
###
colnames(class_preds) <- params$label_names
class_preds
CNN_model
params$cl_output
source('C:/Users/Administrator/Documents/GitHub/NIAB_Rotation/Fruit_model/Pipeline/parameters.R')
setwd(params$folder_containing_scripts)
### load libraries
library(keras)
library(rjson)
library(magick)
library(purrr)
library(tibble)
library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)
library(XML)
library(xml2)
library(jsonlite)
library(tensorflow)
##################################################################################
run_model_trainer<-1 # do we want to train model, or just load an existing one?
params$load <- 0     # if CNN_model is already in the environment, can change to params$load <- 0 to save computational time
run_xml_to_json<-0
##################################################################################
# adds our annotations to the relevant images
if(run_xml_to_json==1){
system("python xmltojson.py")
}
##################################################################################
# CNN
source('CNN_data_generator_and_model_functions.R',echo= TRUE) # generates data and contains functions called upon in CNN model, SVM model and the output analysis file.
####
# check that approx even number of each category present
for(k in 1:length(params$label_names)){
print(paste("Number of training images in category",params$label_names[k],"is",sum(train_data$category_id==k)))
}
####
if(run_model_trainer==1){
source('CNN_model_trainer.R',echo= TRUE) # trains CNN model
}
####
source('CNN_output_analysis.R',echo= TRUE) # analyse resulting CNN (or a loaded CNN)
table_train  # confusion matrix
table_val # confusion matrix
##################################################################################
# SVM stuff from here
source('Disease_fake_data.R',echo= TRUE) # creates dataframes to train SVM model.
source('SVM.R',echo= TRUE) # trains SVM
#####
source('SVM_output_analysis.R',echo= TRUE) # analyse output and create function to test new data
# now can predict for 'new data'
val_data$name[1]
dis_number<-which(name_disease == val_data$name[1])
# assume categorical variables are for the average case of disease appearance
categorical_test_sample<-list('location'=if(crop_bias[[dis_number]]<0){"Midlands"}else{"East_Anglia"},
'rainfall'=rain_av[dis_number],
'mean_temp'=temp_av[dis_number],
'crop_variety'=if(crop_bias[[dis_number]]<0){"WB2"}else{"WB1"},
'soil_type'=if(soil_bias[[dis_number]]<0){"sandy"}else{"clay"})
SVM_predictor(svm_no_images$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
SVM_predictor(svm_im_only$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
SVM_predictor(svm_all$svm_tuned,CNN_model,val_data,categorical_test_sample$location,categorical_test_sample$rainfall,categorical_test_sample$mean_temp,categorical_test_sample$crop_variety,categorical_test_sample$soil_type)
dev.off()
